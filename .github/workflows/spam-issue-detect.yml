name: Daily Spam Cleanup

on:
  schedule:
    # åŒ—äº¬æ—¶é—´æ¯å¤©å‡Œæ™¨2ç‚¹æ‰§è¡Œ (UTC 18:00)
    - cron: '0 18 * * *'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (only report, do not delete)'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      scan_issues:
        description: 'Scan open issues'
        required: false
        default: 'true'
        type: boolean
      scan_closed_issues:
        description: 'Scan closed issues (may find previously closed spam)'
        required: false
        default: 'false'
        type: boolean
      scan_comments:
        description: 'Scan issue comments'
        required: false
        default: 'true'
        type: boolean
      max_issues:
        description: 'Max number of issues to scan (0 = all)'
        required: false
        default: '100'
        type: string

permissions:
  issues: write
  pull-requests: write
  contents: read

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Daily spam scan and cleanup
        uses: actions/github-script@v7
        with:
          script: |
            const dryRun = '${{ inputs.dry_run }}' === 'true';
            const scanIssues = '${{ inputs.scan_issues }}' === 'true';
            const scanClosedIssues = '${{ inputs.scan_closed_issues }}' === 'true';
            const scanComments = '${{ inputs.scan_comments }}' === 'true';
            const maxIssues = parseInt('${{ inputs.max_issues }}') || 100; // é»˜è®¤100ï¼Œ0è¡¨ç¤ºå…¨éƒ¨
            const HOURS_BACK = 24; // åªæ£€æµ‹è¿‡å»24å°æ—¶å†…çš„å†…å®¹
            
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // è®¡ç®—æ—¶é—´èŒƒå›´
            const sinceDate = new Date();
            sinceDate.setHours(sinceDate.getHours() - HOURS_BACK);

            core.info(`ğŸ•’ å¼€å§‹æ¯æ—¥åƒåœ¾å†…å®¹æ‰«æ`);
            core.info(`   æ‰«ææ—¶é—´: ${new Date().toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' })}`);
            core.info(`   æ‰«æèŒƒå›´: æœ€è¿‘${HOURS_BACK}å°æ—¶å†…åˆ›å»ºçš„å†…å®¹`);
            core.info(`   æœ€å¤§æ•°é‡: ${maxIssues === 0 ? 'å…¨éƒ¨' : maxIssues}ä¸ª`);
            core.info(`   å¹²è¿è¡Œæ¨¡å¼: ${dryRun}`);
            core.info(`   æ‰«æå¼€æ”¾Issue: ${scanIssues}`);
            core.info(`   æ‰«æå·²å…³é—­Issue: ${scanClosedIssues}`);
            core.info(`   æ‰«æè¯„è®º: ${scanComments}`);
            core.info(``);

            // åˆ›å»ºæ£€æµ‹å‡½æ•°
            const createAnalyzer = () => {
              return async (content, author, association) => {
                const contentLower = content.toLowerCase();
                
                // æ¶æ„å†…å®¹å…³é”®è¯æ£€æµ‹
                const defamationPatterns = {
                  personalAttacks: [
                    'éª—å­', 'è¯ˆéª—', 'éª—é’±', 'åƒåœ¾', 'åºŸç‰©', 'æ— è€»', 'ä¸è¦è„¸', 'äººæ¸£',
                    'stupid', 'idiot', 'moron', 'scammer', 'fraud', 'cheater'
                  ],
                  falseAccusations: [
                    'å·çªƒ', 'æŠ„è¢­', 'å‰½çªƒ', 'é€ å‡', 'æ¬ºè¯ˆ', 
                    'stealing', 'plagiarism', 'fake',
                  ],
                  extremeEmotions: [
                    'å¤©ç†éš¾å®¹', 'ä¸å¾—å¥½æ­»', 'æ–­å­ç»å­™', 'å»æ­»', 'æ»šè›‹',
                    'die', 'kill yourself', 'go to hell'
                  ],
                  projectDefamation: [
                    'åƒåœ¾é¡¹ç›®', 'éª—å±€', 'åœˆé’±', 'è¿Ÿæ—©å€’é—­', 'å»ºè®®è§£æ•£', 
                    'scam project', 'ponzi scheme', 'worthless'
                  ]
                };

                let score = 0;
                let detectedPatterns = [];

                // è®¡ç®—åˆ†æ•°
                for (const [category, keywords] of Object.entries(defamationPatterns)) {
                  const matches = keywords.filter(keyword => 
                    contentLower.includes(keyword.toLowerCase())
                  );
                  
                  if (matches.length > 0) {
                    detectedPatterns.push(`${category}`);
                    
                    const weights = {
                      personalAttacks: 4,
                      falseAccusations: 3,
                      extremeEmotions: 5,
                      projectDefamation: 4
                    };
                    
                    score += matches.length * weights[category];
                  }
                }

                // è°ƒè¯•ä¿¡æ¯
                core.info(`è¯¦ç»†åˆ†æ: ç”¨æˆ·=${author}, å†…å®¹é•¿åº¦=${content.length}, åˆ†æ•°=${score}, æ¨¡å¼=${detectedPatterns.join(',')}`);

                // å†³ç­–é€»è¾‘
                const isSpam = score >= 10; 

                return {
                  isSpam,
                  score,
                  reason: isSpam ? `æ£€æµ‹åˆ°æ¶æ„å†…å®¹ (åˆ†æ•°: ${score})` : 'æ­£å¸¸å†…å®¹',
                  detectedPatterns
                };
              };
            };

            let totalScanned = 0;
            let totalSpam = 0;
            let totalClosed = 0;
            let totalDeleted = 0;
            let totalModerated = 0;

            try {
              const analyzeContent = createAnalyzer();
              core.info("âœ… åƒåœ¾æ£€æµ‹æ¨¡å—åŠ è½½æˆåŠŸ");

              // æ‰«æå¼€æ”¾ä¸­çš„Issueï¼ˆåªæ‰«ææœ€è¿‘24å°æ—¶å†…çš„ï¼‰
              if (scanIssues) {
                core.info("ğŸ“ æ‰«ææœ€è¿‘24å°æ—¶å†…å¼€æ”¾çš„Issue...");
                let page = 1;
                let openScanned = 0;

                while (maxIssues === 0 || openScanned < maxIssues) {
                  const issues = await github.rest.issues.listForRepo({
                    owner, repo, 
                    state: 'open', 
                    since: sinceDate.toISOString(), // åªè·å–æœ€è¿‘24å°æ—¶å†…çš„
                    per_page: 50,
                    page,
                    sort: 'created',
                    direction: 'desc'
                  });

                  if (issues.data.length === 0) {
                    core.info("ğŸ“­ æ²¡æœ‰æ‰¾åˆ°æ›´å¤šç¬¦åˆæ¡ä»¶çš„å¼€æ”¾Issue");
                    break;
                  }

                  for (const issue of issues.data) {
                    if (issue.pull_request) continue;
                    if (maxIssues > 0 && openScanned >= maxIssues) break;

                    openScanned++;
                    totalScanned++;

                    core.info(`æ‰«æå¼€æ”¾Issue #${issue.number}: "${issue.title}"`);

                    // ç»“åˆæ ‡é¢˜å’Œæ­£æ–‡è¿›è¡Œæ£€æµ‹
                    const fullContent = (issue.title + ' ' + (issue.body || '')).toLowerCase();
                    
                    const analysis = await analyzeContent(
                      fullContent,
                      issue.user?.login || "unknown",
                      issue.author_association || "NONE"
                    );

                    if (analysis.isSpam) {
                      totalSpam++;
                      core.warning(`ğŸš¨ [SPAM] å¼€æ”¾Issue #${issue.number} by @${issue.user?.login}`);
                      core.warning(`   æ ‡é¢˜: ${issue.title}`);
                      core.warning(`   åˆ†æ•°: ${analysis.score}, æ¨¡å¼: ${analysis.detectedPatterns.join(', ')}`);

                      if (!dryRun) {
                        try {
                          await github.rest.issues.update({
                            owner, repo, issue_number: issue.number,
                            state: "closed", state_reason: "not_planned"
                          });
                          await github.rest.issues.createComment({
                            owner, repo, issue_number: issue.number,
                            body: `## ğŸš« è‡ªåŠ¨åƒåœ¾æ£€æµ‹\n\næ­¤Issueåœ¨å®šæ—¶æ‰«æä¸­è¢«è¯†åˆ«ä¸ºè¿è§„å†…å®¹å¹¶å·²è‡ªåŠ¨å…³é—­ã€‚\n\n` +
                                  `**æ£€æµ‹æ—¶é—´:** ${new Date().toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' })}\n` +
                                  `**æ£€æµ‹åˆ†æ•°:** ${analysis.score}\n` +
                                  `**æ£€æµ‹æ¨¡å¼:** ${analysis.detectedPatterns.join(', ')}\n\n` +
                                  `å¦‚æœè¿™æ˜¯è¯¯åˆ¤ï¼Œè¯·è”ç³»ç»´æŠ¤è€…ã€‚`
                          });
                          await github.rest.issues.addLabels({
                            owner, repo, issue_number: issue.number,
                            labels: ['spam', 'auto-removed']
                          });
                          totalClosed++;
                          core.notice(`âœ… å·²å…³é—­åƒåœ¾Issue #${issue.number}`);
                          
                          // APIé€Ÿç‡é™åˆ¶ä¿æŠ¤
                          await new Promise(resolve => setTimeout(resolve, 500));
                        } catch (err) {
                          core.error(`âŒ å…³é—­Issue #${issue.number}å¤±è´¥: ${err.message}`);
                        }
                      } else {
                        core.notice(`âš ï¸  [DRY RUN] æ£€æµ‹åˆ°åƒåœ¾Issue #${issue.number} (æœªæ‰§è¡Œæ“ä½œ)`);
                      }
                    } else {
                      core.info(`âœ… å¼€æ”¾Issue #${issue.number} æ£€æµ‹ä¸ºæ­£å¸¸å†…å®¹`);
                    }
                  }
                  page++;
                }
                core.info(`å¼€æ”¾Issueæ‰«æå®Œæˆ: ${openScanned}ä¸ª`);
              }

              // æ‰«æå·²å…³é—­çš„Issueï¼ˆåªæ‰«ææœ€è¿‘24å°æ—¶å†…çš„ï¼‰
              if (scanClosedIssues) {
                core.info("ğŸ“š æ‰«ææœ€è¿‘24å°æ—¶å†…å·²å…³é—­çš„Issue...");
                let page = 1;
                let closedScanned = 0;

                while (maxIssues === 0 || closedScanned < maxIssues) {
                  const issues = await github.rest.issues.listForRepo({
                    owner, repo, 
                    state: 'closed', 
                    since: sinceDate.toISOString(), // åªè·å–æœ€è¿‘24å°æ—¶å†…çš„
                    per_page: 50, 
                    page,
                    sort: 'created',
                    direction: 'desc'
                  });

                  if (issues.data.length === 0) {
                    core.info("ğŸ“­ æ²¡æœ‰æ‰¾åˆ°æ›´å¤šç¬¦åˆæ¡ä»¶çš„å·²å…³é—­Issue");
                    break;
                  }

                  for (const issue of issues.data) {
                    if (issue.pull_request) continue;
                    if (maxIssues > 0 && closedScanned >= maxIssues) break;

                    closedScanned++;
                    totalScanned++;

                    const fullContent = (issue.title + ' ' + (issue.body || '')).toLowerCase();
                    const analysis = await analyzeContent(
                      fullContent,
                      issue.user?.login || "unknown",
                      issue.author_association || "NONE"
                    );

                    if (analysis.isSpam) {
                      totalSpam++;
                      core.warning(`ğŸš¨ [SPAM] å·²å…³é—­Issue #${issue.number} by @${issue.user?.login}`);
                      core.warning(`   åˆ†æ•°: ${analysis.score}, æ¨¡å¼: ${analysis.detectedPatterns.join(', ')}`);

                      if (!dryRun) {
                        try {
                          await github.rest.issues.update({
                            owner, repo, issue_number: issue.number,
                            title: "[å·²å¤„ç†] å†…å®¹å·²ç§»é™¤",
                            body: "**æ­¤å†…å®¹å› è¿åç¤¾åŒºå‡†åˆ™å·²è¢«è‡ªåŠ¨å¤„ç†ã€‚**\n\n" +
                                  "åŸå§‹å†…å®¹åŒ…å«ä¸å½“è¨€è®ºï¼Œç°å·²è¢«éšè—ã€‚\n\n" +
                                  `**å¤„ç†æ—¶é—´:** ${new Date().toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' })}\n` +
                                  "_æ­¤æ“ä½œæ˜¯åœ¨æ¯æ—¥å†…å®¹æ¸…ç†æ‰«æä¸­è‡ªåŠ¨æ‰§è¡Œçš„ã€‚_"
                          });
                          totalModerated++;
                          core.notice(`âœ… å·²å¤„ç†å·²å…³é—­åƒåœ¾Issue #${issue.number}`);
                          
                          // APIé€Ÿç‡é™åˆ¶ä¿æŠ¤
                          await new Promise(resolve => setTimeout(resolve, 500));
                        } catch (err) {
                          core.error(`âŒ å¤„ç†å·²å…³é—­Issue #${issue.number}å¤±è´¥: ${err.message}`);
                        }
                      } else {
                        core.notice(`âš ï¸  [DRY RUN] æ£€æµ‹åˆ°å·²å…³é—­åƒåœ¾Issue #${issue.number} (æœªæ‰§è¡Œæ“ä½œ)`);
                      }
                    }
                  }
                  page++;
                }
                core.info(`å·²å…³é—­Issueæ‰«æå®Œæˆ: ${closedScanned}ä¸ª`);
              }

              // æ‰«æè¯„è®ºï¼ˆåªæ‰«ææœ€è¿‘24å°æ—¶å†…çš„ï¼‰
              if (scanComments) {
                core.info("ğŸ’¬ æ‰«ææœ€è¿‘24å°æ—¶å†…çš„è¯„è®º...");
                let page = 1;
                let commentCount = 0;

                while (page <= 10 && (maxIssues === 0 || commentCount < maxIssues)) {
                  const comments = await github.rest.issues.listCommentsForRepo({
                    owner, repo, 
                    since: sinceDate.toISOString(), // åªè·å–æœ€è¿‘24å°æ—¶å†…çš„
                    per_page: 50, 
                    page, 
                    sort: 'created', 
                    direction: 'desc'
                  });

                  if (comments.data.length === 0) {
                    core.info("ğŸ“­ æ²¡æœ‰æ‰¾åˆ°æ›´å¤šç¬¦åˆæ¡ä»¶çš„è¯„è®º");
                    break;
                  }

                  for (const comment of comments.data) {
                    if (maxIssues > 0 && commentCount >= maxIssues) break;

                    commentCount++;
                    totalScanned++;

                    const analysis = await analyzeContent(
                      comment.body || "",
                      comment.user?.login || "unknown",
                      comment.author_association || "NONE"
                    );

                    if (analysis.isSpam) {
                      totalSpam++;
                      core.warning(`ğŸš¨ [SPAM] è¯„è®º #${comment.id} by @${comment.user?.login}`);
                      core.warning(`   åˆ†æ•°: ${analysis.score}, æ¨¡å¼: ${analysis.detectedPatterns.join(', ')}`);

                      if (!dryRun) {
                        try {
                          await github.rest.issues.deleteComment({
                            owner, repo, comment_id: comment.id
                          });
                          totalDeleted++;
                          core.notice(`âœ… å·²åˆ é™¤åƒåœ¾è¯„è®º #${comment.id}`);
                          
                          // APIé€Ÿç‡é™åˆ¶ä¿æŠ¤
                          await new Promise(resolve => setTimeout(resolve, 500));
                        } catch (err) {
                          core.error(`âŒ åˆ é™¤è¯„è®º #${comment.id}å¤±è´¥: ${err.message}`);
                        }
                      } else {
                        core.notice(`âš ï¸  [DRY RUN] æ£€æµ‹åˆ°åƒåœ¾è¯„è®º #${comment.id} (æœªæ‰§è¡Œæ“ä½œ)`);
                      }
                    }
                  }
                  page++;
                }
                core.info(`è¯„è®ºæ‰«æå®Œæˆ: ${commentCount}æ¡`);
              }

            } catch (err) {
              core.error(`âŒ æ‰«æè¿‡ç¨‹å‡ºé”™: ${err.message}`);
              core.setFailed(`æ‰§è¡Œå¤±è´¥: ${err.message}`);
              return;
            }

            // ç”Ÿæˆæ€»ç»“æŠ¥å‘Š
            core.notice("=".repeat(60));
            core.notice(`ğŸ“Š æ¯æ—¥æ‰«ææ€»ç»“ ${dryRun ? '(å¹²è¿è¡Œæ¨¡å¼)' : '(å·²æ‰§è¡Œ)'}`);
            core.notice("=".repeat(60));
            core.notice(`ğŸ“ æ‰«æç»Ÿè®¡:`);
            core.notice(`   â€¢ æ‰«ææ—¶é—´èŒƒå›´: æœ€è¿‘${HOURS_BACK}å°æ—¶`);
            core.notice(`   â€¢ æ€»è®¡æ‰«æ: ${totalScanned}`);
            core.notice(``);
            core.notice(`ğŸš¨ æ£€æµ‹ç»“æœ:`);
            core.notice(`   â€¢ å‘ç°çš„åƒåœ¾å†…å®¹: ${totalSpam}`);
            if (!dryRun) {
              core.notice(``);
              core.notice(`âœ… æ‰§è¡Œçš„æ“ä½œ:`);
              core.notice(`   â€¢ å…³é—­çš„Issue: ${totalClosed}`);
              core.notice(`   â€¢ å¤„ç†çš„å·²å…³é—­Issue: ${totalModerated}`);
              core.notice(`   â€¢ åˆ é™¤çš„è¯„è®º: ${totalDeleted}`);
              core.notice(`   â€¢ æ€»è®¡æ“ä½œ: ${totalClosed + totalModerated + totalDeleted}`);
            } else {
              core.notice(``);
              core.notice(`âš ï¸  å¹²è¿è¡Œæ¨¡å¼ - æœªæ‰§è¡Œä»»ä½•æ“ä½œ`);
              core.notice(`   è®¾ç½® dry_run: false æ¥æ‰§è¡Œå®é™…æ¸…ç†`);
            }
            core.notice(``);
            core.notice(`â° ä¸‹æ¬¡æ‰«æ: åŒ—äº¬æ—¶é—´æ˜å¤©å‡Œæ™¨2ç‚¹`);
            core.notice("=".repeat(60));

            if (totalSpam > 0 && dryRun) {
              core.notice(`ğŸ’¡ å»ºè®®: å‘ç° ${totalSpam} ä¸ªæ½œåœ¨çš„åƒåœ¾å†…å®¹ï¼Œè¯·å®¡æŸ¥åæ‰§è¡Œæ¸…ç†ã€‚`);
            }
